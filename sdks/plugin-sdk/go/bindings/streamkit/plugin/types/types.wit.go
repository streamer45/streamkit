// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package types represents the imported interface "streamkit:plugin/types@0.1.0".
//
// Core types for audio processing
package types

import (
	"go.bytecodealliance.org/cm"
)

// SampleFormat represents the enum "streamkit:plugin/types@0.1.0#sample-format".
//
// Sample format for raw audio
//
//	enum sample-format {
//		float32,
//		s16-le
//	}
type SampleFormat uint8

const (
	SampleFormatFloat32 SampleFormat = iota
	SampleFormatS16Le
)

var _SampleFormatStrings = [2]string{
	"float32",
	"s16-le",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e SampleFormat) String() string {
	return _SampleFormatStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e SampleFormat) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *SampleFormat) UnmarshalText(text []byte) error {
	return _SampleFormatUnmarshalCase(e, text)
}

var _SampleFormatUnmarshalCase = cm.CaseUnmarshaler[SampleFormat](_SampleFormatStrings[:])

// AudioFormat represents the record "streamkit:plugin/types@0.1.0#audio-format".
//
// Audio format specification
//
//	record audio-format {
//		sample-rate: u32,
//		channels: u16,
//		sample-format: sample-format,
//	}
type AudioFormat struct {
	_            cm.HostLayout `json:"-"`
	SampleRate   uint32        `json:"sample-rate"`
	Channels     uint16        `json:"channels"`
	SampleFormat SampleFormat  `json:"sample-format"`
}

// PacketType represents the variant "streamkit:plugin/types@0.1.0#packet-type".
//
// Packet types that can flow through the pipeline
//
//	variant packet-type {
//		raw-audio(audio-format),
//		opus-audio,
//		text,
//		binary,
//		any,
//	}
type PacketType cm.Variant[uint8, AudioFormat, AudioFormat]

// PacketTypeRawAudio returns a [PacketType] of case "raw-audio".
func PacketTypeRawAudio(data AudioFormat) PacketType {
	return cm.New[PacketType](0, data)
}

// RawAudio returns a non-nil *[AudioFormat] if [PacketType] represents the variant case "raw-audio".
func (self *PacketType) RawAudio() *AudioFormat {
	return cm.Case[AudioFormat](self, 0)
}

// PacketTypeOpusAudio returns a [PacketType] of case "opus-audio".
func PacketTypeOpusAudio() PacketType {
	var data struct{}
	return cm.New[PacketType](1, data)
}

// OpusAudio returns true if [PacketType] represents the variant case "opus-audio".
func (self *PacketType) OpusAudio() bool {
	return self.Tag() == 1
}

// PacketTypeText returns a [PacketType] of case "text".
func PacketTypeText() PacketType {
	var data struct{}
	return cm.New[PacketType](2, data)
}

// Text returns true if [PacketType] represents the variant case "text".
func (self *PacketType) Text() bool {
	return self.Tag() == 2
}

// PacketTypeBinary returns a [PacketType] of case "binary".
func PacketTypeBinary() PacketType {
	var data struct{}
	return cm.New[PacketType](3, data)
}

// Binary returns true if [PacketType] represents the variant case "binary".
func (self *PacketType) Binary() bool {
	return self.Tag() == 3
}

// PacketTypeAny returns a [PacketType] of case "any".
func PacketTypeAny() PacketType {
	var data struct{}
	return cm.New[PacketType](4, data)
}

// Any returns true if [PacketType] represents the variant case "any".
func (self *PacketType) Any() bool {
	return self.Tag() == 4
}

var _PacketTypeStrings = [5]string{
	"raw-audio",
	"opus-audio",
	"text",
	"binary",
	"any",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v PacketType) String() string {
	return _PacketTypeStrings[v.Tag()]
}

// InputPin represents the record "streamkit:plugin/types@0.1.0#input-pin".
//
// Input pin definition
//
//	record input-pin {
//		name: string,
//		accepts-types: list<packet-type>,
//	}
type InputPin struct {
	_            cm.HostLayout       `json:"-"`
	Name         string              `json:"name"`
	AcceptsTypes cm.List[PacketType] `json:"accepts-types"`
}

// OutputPin represents the record "streamkit:plugin/types@0.1.0#output-pin".
//
// Output pin definition
//
//	record output-pin {
//		name: string,
//		produces-type: packet-type,
//	}
type OutputPin struct {
	_            cm.HostLayout `json:"-"`
	Name         string        `json:"name"`
	ProducesType PacketType    `json:"produces-type"`
}

// NodeMetadata represents the record "streamkit:plugin/types@0.1.0#node-metadata".
//
// Node metadata
//
//	record node-metadata {
//		kind: string,
//		inputs: list<input-pin>,
//		outputs: list<output-pin>,
//		param-schema: string,
//		categories: list<string>,
//	}
type NodeMetadata struct {
	_           cm.HostLayout      `json:"-"`
	Kind        string             `json:"kind"`
	Inputs      cm.List[InputPin]  `json:"inputs"`
	Outputs     cm.List[OutputPin] `json:"outputs"`
	ParamSchema string             `json:"param-schema"`
	Categories  cm.List[string]    `json:"categories"`
}

// AudioFrame represents the record "streamkit:plugin/types@0.1.0#audio-frame".
//
// Audio frame data
//
//	record audio-frame {
//		sample-rate: u32,
//		channels: u16,
//		samples: list<f32>,
//	}
type AudioFrame struct {
	_          cm.HostLayout    `json:"-"`
	SampleRate uint32           `json:"sample-rate"`
	Channels   uint16           `json:"channels"`
	Samples    cm.List[float32] `json:"samples"`
}

// Packet represents the variant "streamkit:plugin/types@0.1.0#packet".
//
// Packet that flows through the pipeline
//
//	variant packet {
//		audio(audio-frame),
//		text(string),
//		binary(list<u8>),
//	}
type Packet cm.Variant[uint8, AudioFrameShape, AudioFrame]

// PacketAudio returns a [Packet] of case "audio".
func PacketAudio(data AudioFrame) Packet {
	return cm.New[Packet](0, data)
}

// Audio returns a non-nil *[AudioFrame] if [Packet] represents the variant case "audio".
func (self *Packet) Audio() *AudioFrame {
	return cm.Case[AudioFrame](self, 0)
}

// PacketText returns a [Packet] of case "text".
func PacketText(data string) Packet {
	return cm.New[Packet](1, data)
}

// Text returns a non-nil *[string] if [Packet] represents the variant case "text".
func (self *Packet) Text() *string {
	return cm.Case[string](self, 1)
}

// PacketBinary returns a [Packet] of case "binary".
func PacketBinary(data cm.List[uint8]) Packet {
	return cm.New[Packet](2, data)
}

// Binary returns a non-nil *[cm.List[uint8]] if [Packet] represents the variant case "binary".
func (self *Packet) Binary() *cm.List[uint8] {
	return cm.Case[cm.List[uint8]](self, 2)
}

var _PacketStrings = [3]string{
	"audio",
	"text",
	"binary",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v Packet) String() string {
	return _PacketStrings[v.Tag()]
}
